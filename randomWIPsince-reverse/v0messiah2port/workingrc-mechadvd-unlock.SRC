;********************************************************************************
;                  h2o-orange-F-ntscconsoleps1fix-v8japsupportadded.sxh				hash 3158b96dd151bdd71406c4c05b80915e
;********************************************************************************
					
;DEFINE

;expermenting defines, not needed.
;SX48RAM			= 	1			; unneeded memory remap, has issues with 75k ps1drv, likely some wrong cals

;SX Chip used. SX48 uncomment below. SX28 have commented.
;SX48			= 	1			; uncomment for compiling for sx48 else is compiled for sx28 F=TR

;RSTBUMP			= 	1			; uncomment for compiling with restbump for ps1mode. sx28 or this and next define aswell for sx48 E51E9226F0360FBAA2510BDFDA0BC433
;USE SX48RSTBUMP ONLY FOR SX COMPILING FOR SX48. Both RSTBUMP and SX48RSTBUMP must be on
;SX48RSTBUMP			= 	1			; uncomment for compiling with restbump for ps1mode. for sx48 with RSTBUMP uncommented	4D74D099733ACDDCBB4F046B4258B20C

;V14/V8jap identiy jmpers. if using sx48 needs the trim, sx28 either can go but stock code is without trim
;H2O75KJMPERS			= 	1			; uncomment for compiling with restbump for ps1mode. if compiling for rstbmp use one of the sx28/sx48 with h2o v14usa/v14jap/v8jap ident jmpers else use F=TR defines  3158B96DD151BDD71406C4C05B80915E
;SX48H2O75KJMPERSTRIM			= 	1			; needed if using h2o jmpers ident with sx48 rstbmp. h needs to go to 5v if not jap console or triggers my cad. D146DFD2DFC6F641029CA7A2A1529DD3

;USE ONLY IF F=TR or RSTBUMP without H2O75KJMPERS.
;pal v14 dont define any. for jap/usa define only one for 75k this will make f=tr work correctly also h=rw usa/pal			f=tr 75k pal sx28 0F465F30D6207AF98456841781DEC442 sx48 A7B089F1BEFF0EE9EE002CB378A1D018
;USAv14			= 	1			;uncomment for fixed 75k being usa region. all prior still work any region		f=tr 75k usa sx28 0F7BAA63B5735E9A0D7C40BAF4E57A7B sx48 CD93EF4293DA0171269FE8C42E7E6D1E
;JAPv14orv8			= 	1			;uncomment for fixed 75k being jap region. all prior still work any region		f=tr 75k jap sx28 17F5B31F88A8CF440BF83BB7B52587F4 sx48 8A998B76CC47D7A65D7C61A4F2901570
;also for v7 to use v9+ mechacon patch for v8 jap support f=tr 

;NTSCPS1YFIX75K		= 	1			;uncomment for 75k NTSC IMPORT YFIX PAL CONSOLE TESTED makes pal off screen but ntsc correct. off pal correct, ntsc crushed.
;NTSCPS1YFIX75K ON rstbump 891246cec7e63bc112c4005b700a7a22 f=tr 75k pal ec962491125e6e2196e215b6cb5222a1 ;;  checksums 75kps1yfix not updated
;only rstbump v8jap tested but rest should be right
	IFDEF	SX48
                   device        SX48,TURBO,BOROFF,OSCHS2,OPTIONX,WDRT006
                    ID                    'ICEREV'
	ELSE			
	device        SX28,TURBO,BOROFF,BANKS8,OSCHS2,OPTIONX
                    ID                    'ICEREV'
	ENDIF

;io pin assignments
IO_SCEX				=		ra.2 ; (PSX:SCEx)RA2(S)
IO_BIOS_OE			=		ra.0 ; (R)
IO_BIOS_CS			=		rb.1 ; (W)					; LOW = BIOS select ; 1 = no access to rom , 0 = access to rom
IO_REST				=		rb.2 ; 						; 1 = normal , 0 = reset
IO_EJECT			=		rb.3 ; (PS2:EJECT)RB3(Z) 			;  1 = tray open , 0 = tray closed
IO_CDDVD_OE_A_1Q		=		ra.1 ; (CDDVD:OE)RA1(A) (flipflop 1Q#) ;A from flip flop
IO_CDDVD_OE_A_1R		=		ra.3 ; (CDDVD:OE)RA3(A) (flipflop 1R#) ;flip flop clr
IO_CDDVD_BUS_i			=		rb.7 ; (I)(CDDVD:D7)
IO_CDDVD_BUS_b			=		rb.4 ; (B)(CDDVD:D2)
IO_CDDVD_BUS_f			=		rb.0 ; (F)(just used for usa v14 jmp or clash with f=tr on v14 usa)
IO_CDDVD_BUS_h			=		rb.6 ; (H)(how determins is jap v14 if connected, assumption is no RW support at all on v14 RSTBUMP unless sync works out for when checked)
IO_CDDVD_BUS			=		rb   ; $06
IO_DVD_DATA			=		rc   ; $07 ; (V)RC0(BIOS:D0) - (M)RC7(BIOS:D7)
	IFDEF	SX48
;regs sx48
VAR_DC1             =           $0A
VAR_DC2             =           $0B
VAR_DC3             =           $0C
VAR_DC4         =           $0D
VAR_PSX_TEMP         =           $10
VAR_PSX_BYTE         =           $11
VAR_PATCH_FLAGS      =           $0E
VAR_SWITCH          =           $0F
VAR_BIOS_REV         =           $12
VAR_BIOS_YR          =           $13
VAR_BIOS_REGION_TEMP    =           $14
VAR_PSX_BITC         =           $15
VAR_PSX_BC_CDDVD_TEMP           =           $16
	ELSE
;regs sx28
VAR_DC1				=		$08 ; DS 1 ; delay counter 1(small)
VAR_DC2				=		$09 ; DS 1 ; delay counter 2(small)
VAR_DC3				=		$0A ; DS 1 ; delay counter 3(big)
VAR_DC4				=		$0b ; DS 1 ; delay counter 4
VAR_PSX_TEMP			=		$0C ; DS 1 ; SEND_SCEX:  rename later
VAR_PSX_BYTE			=		$0D ; DS 1 ; SEND_SCEX:  byte(to send)
VAR_PATCH_FLAGS			=		$0E ; DS 1
VAR_SWITCH			=		$0F ; DS 1
VAR_BIOS_REV			=		$10 ; DS 1 ; 1.X0 THE BIOS REVISION byte infront in BIOS string is X.00
VAR_BIOS_YR			=		$11 ; DS 1 ; byteC of ;BIOS_VERSION_MATCHING
VAR_BIOS_REGION_TEMP		=		$12 ; DS 1 ; temp storage to compare byte7 of ;BIOS_VERSION_MATCHING
VAR_PSX_BITC			=		$13 ; DS 1 ; SEND_SCEX:  bit counter ;note start at 8(works down to 0)
VAR_PSX_BC_CDDVD_TEMP		=		$14 ; DS 1 ; SEND_SCEX:  byte counter  note start at 4(works down to 0) ; also used with mechacon patches and ps1 detect
	ENDIF

;------------------------------------------------------------
;VAR_PATCH_FLAGS
;------------------------------------------------------------
EJ_FLAG = VAR_PATCH_FLAGS.0
;bit 0 used by eject routine

SOFT_RST = VAR_PATCH_FLAGS.1
;soft reset flag for disk patch 

PSX_FLAG = VAR_PATCH_FLAGS.2
;psx mode flag	

V10_FLAG = VAR_PATCH_FLAGS.3	;bios 1.9 or 2.0
;also v10 1.9 bios has own ps1 routine 

UK_FLAG = VAR_PATCH_FLAGS.4

USA_FLAG = VAR_PATCH_FLAGS.5

JAP_FLAG = VAR_PATCH_FLAGS.6

SCEX_FLAG = VAR_PATCH_FLAGS.7
;set when SCEX_LOW loop for injecting. once cleared knows patching done to flow forward

;------------------------------------------------------------
;VAR_SWITCH
;------------------------------------------------------------
V12_FLAG = VAR_SWITCH.0 ;v12 console 2.0 bios set

V12LOGO_FLAG = VAR_SWITCH.1 ;PS1_MODE v12 2.0 bios console flag ?
;SECOND_BIOS_PATCH_END ref if was doing ps1 patching for 2.0 v12 as redirects flow there for different patch. 

JAP_V8 = VAR_SWITCH.2

X_FLAG = VAR_SWITCH.3 
;set when HOLD_BOOT_MODES only clrb when end ?
;can flow onto ps1 reboot into PS1_MODE if detect ps1 media

DEV1_FLAG = VAR_SWITCH.4

V14_FLAG = VAR_SWITCH.5
;set due to W for region of BIOS which decka models

V0_FLAG = VAR_SWITCH.6
;V0 10-18K console flag

;------------------------------------------------------------
;CODE
;------------------------------------------------------------

;mode setup for io's ;todo
;ref SX-SX-Users-Manual-R3.1.pdf section 5.3.2
	IFDEF	SX48
;mode setup for io's ;todo
;ref SX-SX-Users-Manual-R3.1.pdf section 5.3.2
                    org           $0FFF							; Reset Vector
                    reset         STARTUP						; jmp to startup process on reset vector skipping boot inital

;****** Reset of the chip ********************************
                    org           $0000							; PAGE1 000-1FF
;INTERRUPT
;goes to sleep and wait for reset release ( 1 ) or tray close (0) ...		
                    mov           w,#$1f
                    mov           m,w
                    mov           w,#$ff
                    mov           !IO_DVD_DATA,w
                    mov           w,#$ff
                    mov           !IO_CDDVD_BUS,w
                    mov           w,#$ff
                    mov           !ra,w
                    mov           w,#$ff
                    mov           !re,w				
                    mov           w,#$1a
                    mov           m,w
                    mov           w,#$8
                    mov           !IO_CDDVD_BUS,w
                    mov           w,#$19
                    mov           m,w
                    clr           w
                    mov           !IO_CDDVD_BUS,w
                    mov           w,#$1b
                    mov           m,w
                    mov           w,#$f3
                    mov           !IO_CDDVD_BUS,w
                    mov           w,#$1f
                    mov           m,w
                    sleep      

;INIT_CHIP					
STARTUP
                    mov           w,#$1d
                    mov           m,w
                    mov           w,#$f7
                    mov           !IO_CDDVD_BUS,w
	IFDEF	H2O75KJMPERS					
                    mov           w,#$1e			;; extra needed for io v14jmp
                    mov           m,w
                    mov           w,#$be
                    mov           !IO_CDDVD_BUS,w	;; end extra io v14jmp	
	ENDIF					
                    mov           w,#$1f
                    mov           m,w
                    mov           w,#$7
                    mov           !ra,w
                    mov           w,#$ff
                    mov           !IO_CDDVD_BUS,w
                    mov           w,#$ff
                    mov           !IO_DVD_DATA,w
                    mov           w,#$c7
                    mov           !option,w
					
;read power down register
                    clr           fsr
                    mov           w,#$19
                    mov           m,w
                    clr           w
                    mov           !IO_CDDVD_BUS,w
                    mov           VAR_PSX_BITC,w
                    mov           w,#$1f
                    mov           m,w
	ELSE
                    org           $07FF	
                    reset         STARTUP						; jmp to startup process on reset vector skipping boot inital

;****** Reset of the chip ********************************
                    org           $0000							; PAGE1 000-1FF
;INTERRUPT
;goes to sleep and wait for reset release ( 1 ) or tray close (0) ...					
                    mode          $000F
                    mov           w,#$ff					; 1111 1111
                    mov           !IO_DVD_DATA,w				;to be sure ports are input ...
                    mov           w,#$ff					; 1111 1111
                    mov           !IO_CDDVD_BUS,w				;....
                    mov           w,#$ff					; 1111 1111
                    mov           !ra,w						;...
                    mode          $000A						;set up edge register
                    mov           w,#$8						; 0000 1000	
                    mov           !IO_CDDVD_BUS,w				;RB3 wait for LOW ( = 1 ),RB2 wait for hi ( =0 )
                    mode          $0009						;clear all wakeup pending bits
                    clr           w
                    mov           !IO_CDDVD_BUS,w
                    mode          $000B						;enable wakeup...
                    mov           w,#$f3					; 1111 1011
                    mov           !IO_CDDVD_BUS,w				;... on & RB2 (reset) 
                    mode          $000F
                    sleep         
					
;INIT_CHIP					
STARTUP          								;here from stby & wake up...
                    mode          $000D						;TTL/CMOS mode...
                    mov           w,#$f7					;1111 0111
                    mov           !IO_CDDVD_BUS,w				;set IO_EJECT input as cmos ( level '1' > 2.5V ) work better with noise ...
	IFDEF	H2O75KJMPERS
                    mode          $000E						;?		;; h and f io jmpers needed/extra 75k/v8jap 
                    mov           w,#$be					; 1011 1110
                    mov           !IO_CDDVD_BUS,w					;; end
	ENDIF
                    mode          $000F						;port mode
                    mov           w,#$7						; 0000 0111
                    mov           !ra,w						;port mode : all input
                    mov           w,#$ff
                    mov           !IO_CDDVD_BUS,w
                    mov           w,#$ff
                    mov           !IO_DVD_DATA,w
                    mov           w,#$c7
                    mov           !option,w					;rtcc enabled,no int,incr.on clock, prescaler (bit 2,1,0).
					
;read power down register					
                    clr           fsr
                    mode          $0009						;read power down register 
                    clr           w						;clear W
                    mov           !IO_CDDVD_BUS,w				;exchange registers = read pending bits
                    mov           VAR_PSX_BITC,w				;save wake up status ...
                    mode          $000F						;need 'cause removed from patch disk for speed !

		ENDIF	
CLEAR_CONSOLE_INFO_PREFIND
                    clr           VAR_PATCH_FLAGS		;reset all used flag...
                    clr           VAR_SWITCH	
                    jmp           V0_CONSOLE_CDDVD_START					
;--------------------------------------------------------------------------------
CDDVD_PATCH_DATA_v0
;--------------------------------------------------------------------------------
                    jmp           pc+w	

                    retw          $0					; 1
                    retw          $02					; 2
                    retw          $0					; 3
                    retw          $80					; 4
                    retw          $0					; 5
                    retw          $80					; 6
					
				
V0_CONSOLE_CDDVD_START					
                    mov           w,#4;$4
                    mov           VAR_DC1,w
					
V0_AND_BYTE_SYNC1_L1
                    snb           IO_CDDVD_OE_A_1Q			;wait sync byte FF FF FF FF
                    jmp           V0_AND_BYTE_SYNC1_L1
                    clrb          IO_CDDVD_OE_A_1R
                    nop           
                    setb          IO_CDDVD_OE_A_1R
                    mov           w,IO_DVD_DATA
                    mov           VAR_PSX_BC_CDDVD_TEMP,w
                    mov           w,#$FF
                    mov           w,VAR_PSX_BC_CDDVD_TEMP-w
                    sb            z
                    jmp           V0_CONSOLE_CDDVD_START
                    decsz         VAR_DC1
                    jmp           V0_AND_BYTE_SYNC1_L1

V0_AND_BYTE_SYNC1_L2
                    snb           IO_CDDVD_OE_A_1Q			;want byte 10 after FF FF FF FF or reloop (fixed ps2 dvd unlock run)
                    jmp           V0_AND_BYTE_SYNC1_L2
                    clrb          IO_CDDVD_OE_A_1R
                    nop           
                    setb          IO_CDDVD_OE_A_1R
                    mov           w,IO_DVD_DATA
                    mov           VAR_PSX_BC_CDDVD_TEMP,w
                    mov           w,#$10
                    mov           w,VAR_PSX_BC_CDDVD_TEMP-w
                    sb            z
                    jmp           V0_AND_BYTE_SYNC1_L1		
					
V0_CONSOLE_string_sync
                    mov           w,#3
                    mov           VAR_DC1,w
					
V0_AND_BYTE_SYNC1_L1_sync
                    snb           IO_CDDVD_OE_A_1Q			;wait sync byte 5F FF FF 3x in row
                    jmp           V0_AND_BYTE_SYNC1_L1_sync
                    clrb          IO_CDDVD_OE_A_1R
                    nop           
                    setb          IO_CDDVD_OE_A_1R
                    mov           w,IO_DVD_DATA
                    mov           VAR_PSX_BC_CDDVD_TEMP,w
                    mov           w,#$5F
                    mov           w,VAR_PSX_BC_CDDVD_TEMP-w
                    sb            z
                    jmp           V0_CONSOLE_string_sync
					
V0_AND_BYTE_SYNC1_L1_sync1
                    snb           IO_CDDVD_OE_A_1Q	
                    jmp           V0_AND_BYTE_SYNC1_L1_sync1
                    clrb          IO_CDDVD_OE_A_1R
                    nop           
                    setb          IO_CDDVD_OE_A_1R
                    mov           w,IO_DVD_DATA
                    mov           VAR_PSX_BC_CDDVD_TEMP,w
                    mov           w,#$FF
                    mov           w,VAR_PSX_BC_CDDVD_TEMP-w
                    sb            z
                    jmp           V0_CONSOLE_string_sync
					
V0_AND_BYTE_SYNC1_L1_sync2
                    snb           IO_CDDVD_OE_A_1Q	
                    jmp           V0_AND_BYTE_SYNC1_L1_sync2
                    clrb          IO_CDDVD_OE_A_1R
                    nop           
                    setb          IO_CDDVD_OE_A_1R
                    mov           w,IO_DVD_DATA
                    mov           VAR_PSX_BC_CDDVD_TEMP,w
                    mov           w,#$FF
                    mov           w,VAR_PSX_BC_CDDVD_TEMP-w
                    sb            z
                    jmp           V0_CONSOLE_string_sync
					
                    decsz         VAR_DC1
                    jmp           V0_AND_BYTE_SYNC1_L1_sync
					
pIO_DVD_DATAload_var
                    clr           w							; start 0 as universal run
                    mov           VAR_DC2,w
                    mov           w,#6						;6 of bytes to patch after first preloaded total 7
                    mov           VAR_DC3,w
                    mov           w,#$03
                    mov           IO_DVD_DATA,w				;first byte preload ready for in to out change						
patchv0mech		
                    snb           IO_CDDVD_OE_A_1Q	
                    jmp           patchv0mech
                    clrb          IO_CDDVD_OE_A_1R
                    nop           
                    setb          IO_CDDVD_OE_A_1R			
				

                    mov           w,#$1f
                    mov           m,w		
                    mov           w,#$0						; IO_DVD_DATA goes output
                    mov           !IO_DVD_DATA,w
RUN_v0patch1

                    mov           w,VAR_DC2
                    call          CDDVD_PATCH_DATA_v0
RUN_CDDVD_PATCH_v0
                    snb           IO_CDDVD_OE_A_1Q
                    jmp           RUN_CDDVD_PATCH_v0
                    mov           IO_DVD_DATA,w
                    clrb          IO_CDDVD_OE_A_1R
                    inc           VAR_DC2
                    setb          IO_CDDVD_OE_A_1R
                    decsz         VAR_DC3
                    jmp           RUN_v0patch1				
postpatchv0mecha	
                    snb           IO_CDDVD_OE_A_1Q
                    jmp           postpatchv0mecha
                    mov           w,#$ff
                    mov           !IO_DVD_DATA,w
					
PS1_MODE_RB_IO_SET_SLEEP
                    mov           w,#$fb					; 1111 1011
                    mov           !IO_CDDVD_BUS,w				; rb.2 IO_REST rb.3 IO_EJECT enabled
                    sleep         

                    org           $0400						; PAGE4 400-5FF					